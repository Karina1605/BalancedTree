using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;


//Разработать библиотеку для работы со сбалансированным деревом
namespace BalancedTree
{
    /// <summary>
    ///Интерфейс, кототорый должен поддерживаться сбаланстрованным деревом (Добавлен метод DisplayAllTree, не дерево писка) 
    /// </summary>
    /// <typeparam name="T"></typeparam>
    public interface ITree<T>: IEnumerable<T>
    {

        /*
         * Алгоритмы добавления и удаления имеют одинаковую идею, поэтому описаны здесь
         */
        /// <summary>
        /////Добавление элемента node типа Т в сбалансированное дерево
        /// </summary>
        /// <param name="node"></param>
        /*Т.к. по условию нужно реализовать не дерево поиска, выбран следующий алгоритм алгоритм:
         * 1.Обход дерева осуществляется в ширину,
         * 2.На каждом уровне ищется или первый узел с пустым левым или правым узлом
         * 3.Если нашелся с левым - просто вставляем на это место новый узел и операция завершена,
         *  если нашелся с правым - запоминаем его и идем до конца уровня в поисках узла с пустым левым
         * 4.Если на пройденном уровне не нашлось ни одного узла с пустым левым поддеревом, но нашелся узел с пустым правым,
         *  то вставляем новый узел на найденную позицию и завершаем операцию, иначе  - спускаемся на след. уровень 
         *  **В дерево добавляются только уникальные элементы
         */
        void Add(T node);

        /// <summary>
        ///  Очистка дерева
        /// </summary>
        void Clear();


        /// <summary>
        /// //Проверка существования элемента node типа Т в дереве
        /// </summary>
        /// <param name="node"></param>
        /// <returns>bool</returns>
        //Осуществляется рекурсивный проход по всем узлам дерева 
        bool Contains(T node);

        /// <summary>
        /// Удаление элемента node типа Т из дерева
        /// </summary>
        /// <param name="node"></param>
        ///<exception cref="TreeException.TreeException(string)"
        /*
         * Алгоритм удаления:
         * 1.Осуществляется поиск элемента node в дереве
         * 2.Если элемент найден, присваиваем информационной части информационную часть последнего добавленного эл-та в дерево
         *   и удаляем последний элемент, разбалансировка не произойдет ни в каком случае
         */
        void Remove(T node);

        /// <summary>
        ///Свойство, показывающее сколько узлов в текущем дереве на данный момент
        /// </summary>
        int Count { get; }

        /// <summary>
        ///Свойство, указывающее, пусто ли дерево
        /// </summary>
        bool IsEmpty { get; }

        /// <summary>
        ///Перебор всех элементов дерева (в обоих реализациях обход дерева будет в ширину) 
        /// </summary>
        IEnumerable<T> nodes { get; }

        /// <summary>
        ///Метод отображения дерева в TreeView 
        /// </summary>
        /// <param name="tree"></param>
        void DisplayAllTree(TreeView tree);
    }
}
